<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mini Shooter con Niveles y Mejoras</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; 
    font-family: Arial, sans-serif;
    user-select: none;
    background: #222;
  }
  #gameCanvas {
    display: block;
    margin: 0 auto;
    border: 2px solid #555;
  }
  #info {
    color: white;
    text-align: center;
    margin: 5px;
  }
</style>
</head>
<body>

<div id="info">Usa WASD para mover, clic para disparar, mueve el ratón para apuntar.</div>
<canvas id="gameCanvas" width="600" height="400"></canvas>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Ambientes con colores
  const environments = [
    {background:'#2a3b4d', player:'lime', enemy:'red', bullet:'yellow'},
    {background:'#283618', player:'#a1c349', enemy:'#d62828', bullet:'#fca311'},
    {background:'#3e1f47', player:'#9d4edd', enemy:'#f72585', bullet:'#720026'},
    {background:'#0b3c5d', player:'#1fab89', enemy:'#ef476f', bullet:'#ffd166'}
  ];
  let currentEnvIndex = 0;
  let envChangeTimer = 0;
  const envChangeInterval = 60 * 20; // 20 segundos a 60fps

  // Mejoras disponibles
  const upgrades = [
    { name: 'Velocidad Jugador +1', apply: p => p.speed += 1 },
    { name: 'Bala más rápida', apply: p => p.bulletSpeed += 2 },
    { name: 'Bala más grande', apply: p => p.bulletRadius += 2 }
  ];

  // Jugador
  const player = {
    x: canvas.width / 2,
    y: canvas.height - 50,
    width: 30,
    height: 30,
    color: environments[currentEnvIndex].player,
    angle: 0,
    speed: 4,
    bulletSpeed: 7,
    bulletRadius: 5,
    moving: {left:false, right:false, up:false, down:false},
    upgrades: []
  };

  const bullets = [];
  const enemies = [];
  const enemySize = 30;
  let enemySpawnTimer = 0;
  let score = 0;
  let gameOver = false;

  let mouseX = player.x, mouseY = player.y;

  // Niveles y control
  let level = 1;
  const enemiesPerLevel = 20;
  let enemiesKilledThisLevel = 0;
  let upgradeMessage = '';
  let upgradeMessageTimer = 0;

  window.addEventListener('keydown', e => {
    if (e.key === 'a' || e.key === 'A') player.moving.left = true;
    if (e.key === 'd' || e.key === 'D') player.moving.right = true;
    if (e.key === 'w' || e.key === 'W') player.moving.up = true;
    if (e.key === 's' || e.key === 'S') player.moving.down = false;
    if (e.key === 's' || e.key === 'S') player.moving.down = true;
  });

  window.addEventListener('keyup', e => {
    if (e.key === 'a' || e.key === 'A') player.moving.left = false;
    if (e.key === 'd' || e.key === 'D') player.moving.right = false;
    if (e.key === 'w' || e.key === 'W') player.moving.up = false;
    if (e.key === 's' || e.key === 'S') player.moving.down = false;
  });

  window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
    player.angle = Math.atan2(mouseY - player.y, mouseX - player.x);
  });

  window.addEventListener('click', e => {
    if (gameOver) return;
    const dx = Math.cos(player.angle) * player.bulletSpeed;
    const dy = Math.sin(player.angle) * player.bulletSpeed;
    bullets.push({x: player.x, y: player.y, dx, dy, radius: player.bulletRadius, color: environments[currentEnvIndex].bullet});
  });

  function spawnEnemy() {
    const x = Math.random() * (canvas.width - enemySize);
    enemies.push({
      x,
      y: 0,
      width: enemySize,
      height: enemySize,
      color: environments[currentEnvIndex].enemy,
      speed: 1 + Math.random() * 1.5
    });
  }

  function giveUpgrade() {
    // Elegir una mejora que no tenga el jugador
    const available = upgrades.filter(u => !player.upgrades.includes(u.name));
    if(available.length === 0) {
      upgradeMessage = 'Todas las mejoras obtenidas!';
      upgradeMessageTimer = 120;
      return;
    }
    const upgrade = available[Math.floor(Math.random()*available.length)];
    upgrade.apply(player);
    player.upgrades.push(upgrade.name);
    upgradeMessage = 'Mejora obtenida: ' + upgrade.name;
    upgradeMessageTimer = 180;
  }

  function update() {
    if (gameOver) return;

    // Cambiar ambiente por tiempo
    envChangeTimer++;
    if (envChangeTimer > envChangeInterval) {
      currentEnvIndex = (currentEnvIndex + 1) % environments.length;
      envChangeTimer = 0;

      player.color = environments[currentEnvIndex].player;
      bullets.forEach(b => b.color = environments[currentEnvIndex].bullet);
      enemies.forEach(en => en.color = environments[currentEnvIndex].enemy);
    }

    // Mover jugador
    if(player.moving.left) player.x -= player.speed;
    if(player.moving.right) player.x += player.speed;
    if(player.moving.up) player.y -= player.speed;
    if(player.moving.down) player.y += player.speed;

    // Limitar jugador al canvas
    player.x = Math.min(Math.max(player.x, player.width/2), canvas.width - player.width/2);
    player.y = Math.min(Math.max(player.y, player.height/2), canvas.height - player.height/2);

    // Mover balas
    for (let i = bullets.length - 1; i >= 0; i--) {
      let b = bullets[i];
      b.x += b.dx;
      b.y += b.dy;
      if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height){
        bullets.splice(i,1);
      }
    }

    // Mover enemigos
    for (let i = enemies.length - 1; i >= 0; i--) {
      let en = enemies[i];
      en.y += en.speed;
      if (en.y + en.height > canvas.height) {
        gameOver = true;
      }
    }

    // Colisiones balas-enemigos y conteo de eliminados
    for(let i = enemies.length -1; i >= 0; i--) {
      let en = enemies[i];
      for(let j = bullets.length -1; j >= 0; j--) {
        let b = bullets[j];
        if (
          b.x > en.x && b.x < en.x + en.width &&
          b.y > en.y && b.y < en.y + en.height
        ) {
          enemies.splice(i,1);
          bullets.splice(j,1);
          score++;
          enemiesKilledThisLevel++;
          // Cada enemiesPerLevel enemigos mata, subir nivel y dar mejora
          if(enemiesKilledThisLevel >= enemiesPerLevel) {
            level++;
            enemiesKilledThisLevel = 0;
            giveUpgrade();
          }
          break;
        }
      }
    }

    // Generar enemigos con más frecuencia y velocidad en niveles altos
    enemySpawnTimer++;
    if(enemySpawnTimer > Math.max(20, 60 - level*5)) { 
      spawnEnemy();
      enemySpawnTimer = 0;
    }
  }

  function draw() {
    ctx.fillStyle = environments[currentEnvIndex].background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Jugador
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.moveTo(15, 0);
    ctx.lineTo(-15, -10);
    ctx.lineTo(-15, 10);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Balas
    bullets.forEach(b => {
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2);
      ctx.fill();
    });

    // Enemigos
    enemies.forEach(en => {
      ctx.fillStyle = en.color;
      ctx.fillRect(en.x, en.y, en.width, en.height);
    });

    // Puntaje y Nivel
    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.fillText('Puntaje: ' + score, 10, 25);
    ctx.fillText('Nivel: ' + level, 10, 50);

    // Mostrar mensaje de mejora
    if(upgradeMessageTimer > 0) {
      ctx.fillStyle = 'yellow';
      ctx.font = '18px Arial';
      ctx.fillText(upgradeMessage, canvas.width/2, 30);
      ctx.textAlign = 'center';
      upgradeMessageTimer--;
      ctx.textAlign = 'start';
    }

    // Fin del juego
    if(gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'red';
      ctx.font = '40px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Juego Terminado', canvas.width/2, canvas.height/2 - 20);
      ctx.font = '20px Arial';
      ctx.fillText('Refresca la página para reiniciar', canvas.width/2, canvas.height/2 + 20);
      ctx.textAlign = 'start';
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  loop();
</script>

</body>
</html>
